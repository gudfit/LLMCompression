(* File: budget_closure_operators_formalization.v *)

Require Import Stdlib.Sets.Ensembles.
Import Ensembles.
From Stdlib Require Import Init.Logic.
From Stdlib Require Import ssreflect ssrfun ssrbool.


(*===========================================================================*)
(* Section 0: Notation and Basic Setting                                     *)
(*===========================================================================*)

Module Type SETTING.

  Parameter X : Type.
  Parameter le_X : X -> X -> Prop.
  Axiom le_X_refl : forall x : X, le_X x x.
  Axiom le_X_antisym : forall x y : X, le_X x y -> le_X y x -> x = y.
  Axiom le_X_trans : forall x y z : X, le_X x y -> le_X y z -> le_X x z.
  Notation "x <=_X y" := (le_X x y) (at level 70).
  Notation "x <_X y" := (le_X x y /\ x <> y) (at level 70).

  Parameter Lambda : Type.
  Parameter le_Lambda : Lambda -> Lambda -> Prop.
  Axiom Lambda_non_empty : inhabited Lambda.
  Axiom le_Lambda_refl : forall l : Lambda, le_Lambda l l.
  Axiom le_Lambda_antisym : forall l1 l2 : Lambda, le_Lambda l1 l2 -> le_Lambda l2 l1 -> l1 = l2.
  Axiom le_Lambda_trans : forall l1 l2 l3 : Lambda, le_Lambda l1 l2 -> le_Lambda l2 l3 -> le_Lambda l1 l3.
  Notation "l1 <= l2" := (le_Lambda l1 l2) (at level 70).
  Notation "l1 < l2" := (le_Lambda l1 l2 /\ l1 <> l2) (at level 70).

  Definition IsDirected (D : Ensemble Lambda) : Prop :=
    (Stdlib.Sets.Ensembles.Inhabited Lambda D) /\
    (forall l1 l2 : Lambda, D l1 -> D l2 -> exists l_upper_bound : Lambda, D l_upper_bound /\ l1 <= l_upper_bound /\ l2 <= l_upper_bound).

  Parameter supremum : Ensemble Lambda -> Lambda.
  Axiom supremum_is_least_upper_bound :
    forall (D : Ensemble Lambda), IsDirected D ->
      ( (forall l_in_D : Lambda, D l_in_D -> l_in_D <= (supremum D)) /\
        (forall upper_b : Lambda, (forall l_in_D : Lambda, D l_in_D -> l_in_D <= upper_b) -> (supremum D) <= upper_b)
      ).

  Definition Powerset (P : Type) : Type := Ensemble P.
  Definition lower_closure (A : Powerset X) : Powerset X :=
    fun p_elem : X => exists a_elem : X, A a_elem /\ p_elem <=_X a_elem.
  Notation "'lc' A" := (lower_closure A) (at level 40).
  Definition minimals (A : Powerset X) : Powerset X :=
    fun a_elem : X => A a_elem /\ (forall a_prime : X, A a_prime -> a_prime <=_X a_elem -> a_prime = a_elem).
  Notation "'Min_X' ( A )" := (minimals A) (at level 60).

End SETTING.


(*===========================================================================*)
(* Section 1: Budget-Indexed Closure Operators                             *)
(*===========================================================================*)

Module BUDGET_INDEXED_CLOSURE_OPERATORS (S : SETTING).

  Import S.

  Parameter K_op : Lambda -> (Powerset X -> Powerset X).
  Notation K_lambda l := (K_op l).

  Axiom A1_Extensivity :
    forall (l : Lambda) (A : Powerset X),
    Included X A (K_lambda l A).

  Axiom A2_Idempotence :
    forall (l : Lambda) (A : Powerset X),
    Same_set X (K_lambda l (K_lambda l A)) (K_lambda l A).

  Axiom A3_Monotonicity_in_A :
    forall (l : Lambda) (A B : Powerset X),
    Included X A B -> Included X (K_lambda l A) (K_lambda l B).

  Definition Union_indexed (idx_set : Ensemble Lambda) (fam : Lambda -> Powerset X) : Powerset X :=
    fun x_val : X => exists l_idx : Lambda, idx_set l_idx /\ (fam l_idx x_val).

  Axiom A4_Scott_Continuity_in_lambda :
    forall (A : Powerset X) (D : Ensemble Lambda) (lambda_star : Lambda),
    IsDirected D ->
    lambda_star = supremum D ->
    Same_set X (K_lambda lambda_star A) (Union_indexed D (fun l' => K_lambda l' A)).

  Theorem P1_Monotonicity_in_lambda :
    forall (A : Powerset X) (l1 l2 : Lambda),
    l1 <= l2 -> Included X (K_lambda l1 A) (K_lambda l2 A).
  Proof.
  Admitted.

  (*===========================================================================*)
  (* Section 2: Information Objects and Contexts                             *)
  (*===========================================================================*)

  Definition InformationObject := Powerset X.

  Definition CorrectedInformation (l : Lambda) (S : InformationObject) : Powerset X :=
    K_lambda l S.

  Definition Contexts (l : Lambda) : Ensemble (Powerset X) :=
    fun (C : Powerset X) => Same_set X (K_lambda l C) C.



  Lemma X_is_context : forall (l : Lambda),
      Contexts l (Full_set X).
  Proof.
    intros l.
    unfold Contexts.
    unfold Same_set.
    split.
    - (* Prove K_lambda l (Full_set X) is included in Full_set X *)
      intros x Hx.
      apply Full_intro.
    - (* Prove Full_set X is included in K_lambda l (Full_set X) *)
      intros x Hx.
      apply A1_Extensivity.
      apply Full_intro.
  Qed.

  Definition Meet_Contexts (l : Lambda) (Coll_Ctx : Ensemble (Powerset X)) : Powerset X :=
    fun x : X => forall C_i : Powerset X, Coll_Ctx C_i -> C_i x.


  Definition BigUnion (F : Ensemble (Powerset X)) : Powerset X :=
    fun x => exists C, F C /\ C x.

  Definition Join_Contexts (l : Lambda) (Coll_Ctx : Ensemble (Powerset X)) : Powerset X :=
    K_lambda l (BigUnion Coll_Ctx).

  Theorem contexts_complete_lattice : forall (l : Lambda) (Coll_Ctx : Ensemble (Powerset X)),
    (forall C, Coll_Ctx C -> Contexts l C) ->
    (exists inf, Contexts l inf /\
        (forall C, Coll_Ctx C -> Included X inf C) /\
        (forall T, Contexts l T -> (forall C, Coll_Ctx C -> Included X T C) -> Included X T inf)
    ) /\
    (exists sup, Contexts l sup /\
        (forall C, Coll_Ctx C -> Included X C sup) /\
        (forall T, Contexts l T -> (forall C, Coll_Ctx C -> Included X C T) -> Included X sup T)
    ).
  Proof.
  intros l0 Coll_Ctx H_Coll.
  split.
  (* Infimum *)
  - exists (Meet_Contexts l0 Coll_Ctx).
    assert (Contexts l0 (Meet_Contexts l0 Coll_Ctx)) as H_meet_ctx.
    {
      unfold Contexts, Meet_Contexts, Same_set.
      split.
      + (* K(M) ⊆ M *)
        intros x Hx_KM C_i HC_i.
        (* C_i is a context, so K C_i ⊆ C_i *)
        destruct (H_Coll C_i HC_i) as [H_KCi_Ci _].
        (* Need K(M) x -> C_i x *)
        assert (Included X (K_lambda l0 (Meet_Contexts l0 Coll_Ctx)) (K_lambda l0 C_i)) as H_incl.
        { apply A3_Monotonicity_in_A.
          intros y Hy_M.
          apply Hy_M; exact HC_i. }
        assert (K_lambda l0 C_i x) by (apply H_incl; exact Hx_KM).
        apply (H_KCi_Ci x) in H; assumption.
      + (* M ⊆ K(M) *)
        intros x Hx_M.
        apply (A1_Extensivity l0 (Meet_Contexts l0 Coll_Ctx)); exact Hx_M.
    }
    split; [exact H_meet_ctx|].
    split.
    + (* Meet is lower bound *)
      intros C HC x Hx_M.
      apply Hx_M; exact HC.
    + (* Meet is greatest lower bound *)
      intros T H_T_ctx H_T_lb x Hx_T C HC.
      apply (H_T_lb C HC x Hx_T).
  (* Supremum *)
  - exists (Join_Contexts l0 Coll_Ctx).
    assert (Contexts l0 (Join_Contexts l0 Coll_Ctx)) as H_join_ctx.
    { unfold Contexts, Join_Contexts.
      apply (A2_Idempotence l0 (BigUnion Coll_Ctx)). }
    split; [exact H_join_ctx|].
    split.
    + (* Join is upper bound *)
      intros C HC x Hx_C.
      unfold Join_Contexts.
      apply (A1_Extensivity l0). exists C. split; assumption.
    + (* Join is least upper bound *)
      intros T H_T_ctx H_T_ub x Hx_join.
      (* inclusion BigUnion ⊆ T *)
      assert (Included X (BigUnion Coll_Ctx) T) as H_BigUnion_T.
      {
        intros y [C [HC Hy_C]].
        apply (H_T_ub C HC y Hy_C).
      }
      assert (Included X (K_lambda l0 (BigUnion Coll_Ctx)) (K_lambda l0 T)) as H_Kincl.
      { apply A3_Monotonicity_in_A; exact H_BigUnion_T. }
      assert (H_KT : K_lambda l0 T x) by (apply H_Kincl; exact Hx_join).
      destruct H_T_ctx as [H_KT_T _].
      apply (H_KT_T x); exact H_KT.
  Qed.
End BUDGET_INDEXED_CLOSURE_OPERATORS.